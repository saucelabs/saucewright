#!/usr/bin/env node

import {program} from 'commander';
import * as fs from 'fs';
import YAML from 'yaml';
import {spawn} from 'child_process';
import path from 'path';
import type {PlaywrightTestConfig} from '@playwright/test';
import {requireOrImportDefaultObject} from './load';

const kDefaultConfigFiles = ['playwright.config.ts', 'playwright.config.js', 'playwright.config.mjs'];

type Options = {
  browser?: string, // TODO what do about browser === 'all'?
  headed?: boolean,
  grep?: string,
  grepInvert?: string,
  [key: string]: any
};

program
  .command('test')
  .argument('[test-filter...]', 'Pass arguments to filter test files. Each argument is treated as a regular expression.')
  .option('--browser <browser>', `Browser to use for tests, one of "all", "chromium", "firefox" or "webkit" (default: "chromium").`)
  .option('--headed', 'Run tests in headed browsers (default: headless).')
  .option('-g, --grep <grep>', `Only run tests matching this regular expression (default: ".*").`)
  .option('-gv, --grep-invert <grep>', `Only run tests that do not match this regular expression.`)
  .option('--project <project-name...>', 'Only run tests from the specified list of projects (default: run all projects).')
  .action(async (args: string[], opts: Options) => {
    const resolvedConfigFile = await resolveConfigFile(process.cwd());
    if (!resolvedConfigFile) {
      throw new Error('no playwright config found');
    }
    const playwrightCfg = await loadConfigFromResolvedFile(resolvedConfigFile);

    const cfg: SauceConfig = {
      apiVersion: 'v1alpha',
      kind: 'playwright',
      playwright: {
        version: '1.28.1', // TODO determine version dynamically using semver
        configFile: path.basename(resolvedConfigFile)
      },
      rootDir: './',
      suites: projectsToSuites(args, playwrightCfg, opts)
    }

    const yaml = `# This file was automatically generated by saucewright.
${YAML.stringify(cfg, {aliasDuplicateObjects: false})}`

    // TODO make output configurable
    fs.writeFileSync('saucectl.autogen.config.yml', yaml, {encoding: 'utf8'});

    const p = spawn('saucectl', ['run', '-c', 'saucectl.autogen.config.yml']);
    p.stdout.pipe(process.stdout);
    p.stderr.pipe(process.stderr);
    p.on('exit', (code) => {
      process.exit(code ?? 1);
    });
  });

program.parse();

type SauceConfig = {
  apiVersion: string
  kind: string
  playwright: {
    version: string
    configFile: string
  }
  rootDir: string
  suites: Suite[];
}

type Suite = {
  name: string
  testMatch: (string | RegExp)[]
  params: {
    browserName: string
    project?: string
    headless?: boolean
    grep?: string | RegExp
    grepInvert?: string | RegExp
  }
}

// Alias for playwright's accepted types for the testMatch field.
type TestMatch = string | RegExp | (string | RegExp)[] | undefined;

/**
 * Determine which testMatch to use.
 * See https://playwright.dev/docs/api/class-testproject#test-project-test-match and especially
 * https://github.com/microsoft/playwright/issues/18717 for the order.
 *
 * @param args testMatch via CLI
 * @param global testMatch via global level config
 * @param project testMatch via project level config
 */
function testMatch(args: string[], global?: TestMatch, project?: TestMatch): (string | RegExp)[] {
  let match = project || global || [];
  if (!(match instanceof Array)) {
    match = [match];
  }

  if (args.length > 0) {
    match.push(...args);
  }

  return match.length > 0 ? match : ['.*(test|spec)\\.(js|ts|mjs)'];
}

function projectsToSuites(args: string[], cfg: PlaywrightTestConfig, opts: Options) {
  const suites: Suite[] = [];

  // Conjure up a default suite if no projects exist.
  if (!cfg.projects) {
    suites.push(
      {
        name: new Date().toISOString(),
        testMatch: testMatch(args, cfg.testMatch),
        params: {
          browserName: opts.browser ?? 'chromium',
          headless: !opts.headed,
          grep: opts.grep,
          grepInvert: opts.grepInvert
        }
      }
    );

    return suites;
  }

  for (const p of cfg.projects) {
    if (!p.name) {
      console.error(`Detected an unnamed project in the configuration: ${p}`);
      throw new Error('unnamed projects are not supported');
    }

    // Skip configured projects if the user filtered on project name.
    if (opts.project && !opts.project.includes(p.name)) {
      continue;
    }

    // The playwright CLI only allows one grep pattern, but the config file supports an array. However,
    // saucectl does not support arrays for grep/grepInvert.
    const configGrep = cfg.grep || p.grep;
    const configGrepInvert = cfg.grepInvert || p.grepInvert;
    if (configGrep instanceof Array || configGrepInvert instanceof Array) {
      throw new Error('grep/grepInvert arrays are not supported');
    }

    suites.push({
      name: p.name,
      testMatch: testMatch(args, cfg.testMatch, p.testMatch),
      params: {
        browserName: opts.browser ?? (p.use?.browserName || cfg.use?.browserName || p.use?.defaultBrowserType || 'chromium'),
        project: p.name,
        headless: opts.headed ? false : p.use?.headless || cfg.use?.headless,
        grep: opts.grep ?? configGrep,
        grepInvert: opts.grepInvert ?? configGrepInvert,
      }
    });
  }

  return suites;
}

function resolveConfigFile(configFileOrDirectory: string): string | null {
  const resolveConfig = (configFile: string) => {
    if (fs.existsSync(configFile)) {
      return configFile;
    }

    return null;
  };

  const resolveConfigFileFromDirectory = (directory: string) => {
    for (const configName of kDefaultConfigFiles) {
      const configFile = resolveConfig(path.resolve(directory, configName));
      if (configFile)
        return configFile;
    }
  };

  if (!fs.existsSync(configFileOrDirectory)) {
    throw new Error(`${configFileOrDirectory} does not exist`);
  }
  if (fs.statSync(configFileOrDirectory).isDirectory()) {
    // When passed a directory, look for a config file inside.
    const configFile = resolveConfigFileFromDirectory(configFileOrDirectory);
    if (configFile)
      return configFile;
    // If there is no config, assume this as a root testing directory.
    return null;
  } else {
    // When passed a file, it must be a config file.
    return resolveConfig(configFileOrDirectory);
  }
}

async function loadConfigFromResolvedFile(file: string) {
  return await requireOrImportDefaultObject(file) as PlaywrightTestConfig;
}
